/**
 *  @file       EngineProperties.cpp
 *  @brief      Properties for the Engine module.
 *  @author     gdprop tool.
 *
 *  WARNING!
 *  This file has been autogenerated, all change made will be lost!
 */
#include "Engine.h"
#include "EngineEnums.h"

#if GD_CFG_USE_PROPERTIES == GD_ENABLED

#include ".\World\Camera.h"
#include ".\World\Entity.h"
#include ".\World\FollowCamera.h"
#include ".\World\ParticleEmitter.h"
#include ".\World\SkyDome.h"
#include ".\World\Terrain.h"
#include ".\World\TestEntities\TestProperties.h"


namespace Gamedesk {


void Camera::StaticRegisterProperties( Class* pClass )
{
    if( pClass != Camera::StaticClass() )
        return;

    // mFovAngle
    static PropertyFloat mFovAngleProperty("FOV Angle", "Field of view angle in degree", (UInt32)&((Camera*)(0))->mFovAngle );
    pClass->AddProperty(&mFovAngleProperty);
    mFovAngleProperty.UseRangeValidation(1);
    mFovAngleProperty.SetMinimum((Float)5);
    mFovAngleProperty.SetMaximum((Float)179);

    // mNearView
    static PropertyFloat mNearViewProperty("Near Plane Distance", "Distance to near clipping plane", (UInt32)&((Camera*)(0))->mNearView );
    pClass->AddProperty(&mNearViewProperty);
    mNearViewProperty.UseRangeValidation(1);
    mNearViewProperty.SetMinimum((Float)0);
    mNearViewProperty.SetMaximum((Float)100);

    // mFarView
    static PropertyFloat mFarViewProperty("Far Plane Distance", "Distance to far clipping plane", (UInt32)&((Camera*)(0))->mFarView );
    pClass->AddProperty(&mFarViewProperty);
    mFarViewProperty.UseRangeValidation(1);
    mFarViewProperty.SetMinimum((Float)100);
    mFarViewProperty.SetMaximum((Float)3.40282e+038);

}

void Entity::StaticRegisterProperties( Class* pClass )
{
    if( pClass != Entity::StaticClass() )
        return;

    // mPosition
    static PropertyVector3f mPositionProperty("Position", "Position of the entity in the world", (UInt32)&((Entity*)(0))->mPosition );
    pClass->AddProperty(&mPositionProperty);

    // mOrientation
    static PropertyQuaternionf mOrientationProperty("Orientation", "Orientation of the entity in the world", (UInt32)&((Entity*)(0))->mOrientation );
    pClass->AddProperty(&mOrientationProperty);

}

void FollowCamera::StaticRegisterProperties( Class* pClass )
{
    if( pClass != FollowCamera::StaticClass() )
        return;

    // mSpringForce
    static PropertyFloat mSpringForceProperty("Spring Force", "Force of the spring which will try to bring the camera to it's ideal position", (UInt32)&((FollowCamera*)(0))->mSpringForce );
    pClass->AddProperty(&mSpringForceProperty);
    mSpringForceProperty.UseRangeValidation(1);
    mSpringForceProperty.SetMinimum((Float)0.1);
    mSpringForceProperty.SetMaximum((Float)5);

    // mFollowDistance
    static PropertyFloat mFollowDistanceProperty("Distance", "Distance from the followed entity", (UInt32)&((FollowCamera*)(0))->mFollowDistance );
    pClass->AddProperty(&mFollowDistanceProperty);
    mFollowDistanceProperty.UseRangeValidation(1);
    mFollowDistanceProperty.SetMinimum((Float)1);
    mFollowDistanceProperty.SetMaximum((Float)100);

    // mUpOffset
    static PropertyFloat mUpOffsetProperty("Height", "Height relative to the followed entity", (UInt32)&((FollowCamera*)(0))->mUpOffset );
    pClass->AddProperty(&mUpOffsetProperty);
    mUpOffsetProperty.UseRangeValidation(1);
    mUpOffsetProperty.SetMinimum((Float)0);
    mUpOffsetProperty.SetMaximum((Float)10);

}

void ParticleEmitter::StaticRegisterProperties( Class* pClass )
{
    if( pClass != ParticleEmitter::StaticClass() )
        return;

    // mMaxParticleCount
    static PropertyUInt32 mMaxParticleCountProperty("Max Particle Count", "Maximum number of particles living at once", (UInt32)&((ParticleEmitter*)(0))->mMaxParticleCount );
    pClass->AddProperty(&mMaxParticleCountProperty);
    mMaxParticleCountProperty.UseRangeValidation(1);
    mMaxParticleCountProperty.SetMinimum((UInt32)0);
    mMaxParticleCountProperty.SetMaximum((UInt32)10000);

    // mEmissionConeAngle
    static PropertyUInt32 mEmissionConeAngleProperty("Emission Cone Cutoff", "Angle at which the particles will be emitted", (UInt32)&((ParticleEmitter*)(0))->mEmissionConeAngle );
    pClass->AddProperty(&mEmissionConeAngleProperty);
    mEmissionConeAngleProperty.UseRangeValidation(1);
    mEmissionConeAngleProperty.SetMinimum((UInt32)1);
    mEmissionConeAngleProperty.SetMaximum((UInt32)180);

    // mBirthrate
    static PropertyUInt32 mBirthrateProperty("Birthrate", "Number of particles spawned per seconds", (UInt32)&((ParticleEmitter*)(0))->mBirthrate );
    pClass->AddProperty(&mBirthrateProperty);
    mBirthrateProperty.UseRangeValidation(1);
    mBirthrateProperty.SetMinimum((UInt32)0);
    mBirthrateProperty.SetMaximum((UInt32)10000);

    // mLife
    static PropertyFloat mLifeProperty("Life", "Length of the life of a particle in seconds", (UInt32)&((ParticleEmitter*)(0))->mLife );
    pClass->AddProperty(&mLifeProperty);
    mLifeProperty.UseRangeValidation(1);
    mLifeProperty.SetMinimum((Float)0.1);
    mLifeProperty.SetMaximum((Float)10);

    // mLifeRand
    static PropertyFloat mLifeRandProperty("Life Random", "Random value applied to the life of each particle, in seconds", (UInt32)&((ParticleEmitter*)(0))->mLifeRand );
    pClass->AddProperty(&mLifeRandProperty);
    mLifeRandProperty.UseRangeValidation(1);
    mLifeRandProperty.SetMinimum((Float)0);
    mLifeRandProperty.SetMaximum((Float)10);

    // mSizeStart
    static PropertyFloat mSizeStartProperty("Size Start", "Size of the particles at their birth", (UInt32)&((ParticleEmitter*)(0))->mSizeStart );
    pClass->AddProperty(&mSizeStartProperty);
    mSizeStartProperty.UseRangeValidation(1);
    mSizeStartProperty.SetMinimum((Float)0.1);
    mSizeStartProperty.SetMaximum((Float)10);

    // mSizeStartRand
    static PropertyFloat mSizeStartRandProperty("Size Start Random", "Random value applied to the size of each particles at their birth", (UInt32)&((ParticleEmitter*)(0))->mSizeStartRand );
    pClass->AddProperty(&mSizeStartRandProperty);
    mSizeStartRandProperty.UseRangeValidation(1);
    mSizeStartRandProperty.SetMinimum((Float)0);
    mSizeStartRandProperty.SetMaximum((Float)10);

    // mSizeEnd
    static PropertyFloat mSizeEndProperty("Size End", "Size of the particles at their death", (UInt32)&((ParticleEmitter*)(0))->mSizeEnd );
    pClass->AddProperty(&mSizeEndProperty);
    mSizeEndProperty.UseRangeValidation(1);
    mSizeEndProperty.SetMinimum((Float)0.1);
    mSizeEndProperty.SetMaximum((Float)10);

    // mSizeEndRand
    static PropertyFloat mSizeEndRandProperty("Size End Random", "Random value applied to the size of each particles at their death", (UInt32)&((ParticleEmitter*)(0))->mSizeEndRand );
    pClass->AddProperty(&mSizeEndRandProperty);
    mSizeEndRandProperty.UseRangeValidation(1);
    mSizeEndRandProperty.SetMinimum((Float)0);
    mSizeEndRandProperty.SetMaximum((Float)10);

    // mColorStart
    static PropertyColor4f mColorStartProperty("Color Start", "Color of each particles at their birth", (UInt32)&((ParticleEmitter*)(0))->mColorStart );
    pClass->AddProperty(&mColorStartProperty);

    // mColorEnd
    static PropertyColor4f mColorEndProperty("Color End", "Color of each particles at their death", (UInt32)&((ParticleEmitter*)(0))->mColorEnd );
    pClass->AddProperty(&mColorEndProperty);

    // mInitialSpeed
    static PropertyFloat mInitialSpeedProperty("Initial Speed", "Speed of each particles at their birth", (UInt32)&((ParticleEmitter*)(0))->mInitialSpeed );
    pClass->AddProperty(&mInitialSpeedProperty);
    mInitialSpeedProperty.UseRangeValidation(1);
    mInitialSpeedProperty.SetMinimum((Float)0);
    mInitialSpeedProperty.SetMaximum((Float)10);

    // mInitialSpeedRand
    static PropertyFloat mInitialSpeedRandProperty("Initial Speed Random", "Random value applied to the speed of each particles at their birth", (UInt32)&((ParticleEmitter*)(0))->mInitialSpeedRand );
    pClass->AddProperty(&mInitialSpeedRandProperty);
    mInitialSpeedRandProperty.UseRangeValidation(1);
    mInitialSpeedRandProperty.SetMinimum((Float)0);
    mInitialSpeedRandProperty.SetMaximum((Float)10);

    // mAccel
    static PropertyFloat mAccelProperty("Acceleration", "Acceleration of the particle during its lifetime", (UInt32)&((ParticleEmitter*)(0))->mAccel );
    pClass->AddProperty(&mAccelProperty);
    mAccelProperty.UseRangeValidation(1);
    mAccelProperty.SetMinimum((Float)0.1);
    mAccelProperty.SetMaximum((Float)10);

    // mGravity
    static PropertyVector3f mGravityProperty("Gravity", "Force of the gravity", (UInt32)&((ParticleEmitter*)(0))->mGravity );
    pClass->AddProperty(&mGravityProperty);

}

void SkyDome::StaticRegisterProperties( Class* pClass )
{
    if( pClass != SkyDome::StaticClass() )
        return;

    // mTextureName
    static PropertyString mTextureNameProperty("TextureName", "Texture name (currently does nothing...)", (UInt32)&((SkyDome*)(0))->mTextureName );
    pClass->AddProperty(&mTextureNameProperty);

}

void Terrain::StaticRegisterProperties( Class* pClass )
{
    if( pClass != Terrain::StaticClass() )
        return;

    // mTextureName
    static PropertyString mTextureNameProperty("TextureName", "Texture name (does nothing...)", (UInt32)&((Terrain*)(0))->mTextureName );
    pClass->AddProperty(&mTextureNameProperty);

}

void TestProperties::StaticRegisterProperties( Class* pClass )
{
    if( pClass != TestProperties::StaticClass() )
        return;

    // mBool
    static PropertyBool mBoolProperty("Bool", "", (UInt32)&((TestProperties*)(0))->mBool );
    pClass->AddProperty(&mBoolProperty);

    // mChar
    static PropertyChar mCharProperty("Char", "", (UInt32)&((TestProperties*)(0))->mChar );
    pClass->AddProperty(&mCharProperty);
    mCharProperty.UseRangeValidation(0);
    mCharProperty.SetMinimum((Char)-128);
    mCharProperty.SetMaximum((Char)127);

    // mInt16
    static PropertyInt16 mInt16Property("Int16", "", (UInt32)&((TestProperties*)(0))->mInt16 );
    pClass->AddProperty(&mInt16Property);
    mInt16Property.UseRangeValidation(0);
    mInt16Property.SetMinimum((Int16)-32768);
    mInt16Property.SetMaximum((Int16)32767);

    // mInt32
    static PropertyInt32 mInt32Property("Int32", "", (UInt32)&((TestProperties*)(0))->mInt32 );
    pClass->AddProperty(&mInt32Property);
    mInt32Property.UseRangeValidation(0);
    mInt32Property.SetMinimum((Int16)-32768);
    mInt32Property.SetMaximum((Int16)32767);

    // mInt64
    static PropertyInt64 mInt64Property("Int64", "", (UInt32)&((TestProperties*)(0))->mInt64 );
    pClass->AddProperty(&mInt64Property);
    mInt64Property.UseRangeValidation(0);
    mInt64Property.SetMinimum((Int64)-9223372036854775808);
    mInt64Property.SetMaximum((Int64)9223372036854775807);

    // mByte
    static PropertyByte mByteProperty("Byte", "", (UInt32)&((TestProperties*)(0))->mByte );
    pClass->AddProperty(&mByteProperty);
    mByteProperty.UseRangeValidation(0);
    mByteProperty.SetMinimum((Byte)0);
    mByteProperty.SetMaximum((Byte)255);

    // mUInt16
    static PropertyUInt16 mUInt16Property("UInt16", "", (UInt32)&((TestProperties*)(0))->mUInt16 );
    pClass->AddProperty(&mUInt16Property);
    mUInt16Property.UseRangeValidation(0);
    mUInt16Property.SetMinimum((UInt16)0);
    mUInt16Property.SetMaximum((UInt16)65535);

    // mUInt32
    static PropertyUInt32 mUInt32Property("UInt32", "", (UInt32)&((TestProperties*)(0))->mUInt32 );
    pClass->AddProperty(&mUInt32Property);
    mUInt32Property.UseRangeValidation(0);
    mUInt32Property.SetMinimum((UInt32)0);
    mUInt32Property.SetMaximum((UInt32)4294967295);

    // mUInt64
    static PropertyUInt64 mUInt64Property("UInt64", "", (UInt32)&((TestProperties*)(0))->mUInt64 );
    pClass->AddProperty(&mUInt64Property);
    mUInt64Property.UseRangeValidation(0);
    mUInt64Property.SetMinimum((UInt64)0);
    mUInt64Property.SetMaximum((UInt64)18446744073709551615);

    // mFloat
    static PropertyFloat mFloatProperty("Float", "", (UInt32)&((TestProperties*)(0))->mFloat );
    pClass->AddProperty(&mFloatProperty);
    mFloatProperty.UseRangeValidation(0);
    mFloatProperty.SetMinimum((Float)-3.40282e+038);
    mFloatProperty.SetMaximum((Float)3.40282e+038);

    // mDouble
    static PropertyDouble mDoubleProperty("Double", "", (UInt32)&((TestProperties*)(0))->mDouble );
    pClass->AddProperty(&mDoubleProperty);
    mDoubleProperty.UseRangeValidation(0);
    mDoubleProperty.SetMinimum((Double)-1.79769e+308);
    mDoubleProperty.SetMaximum((Double)1.79769e+308);

    // mColor3
    static PropertyColor3f mColor3Property("Color3", "", (UInt32)&((TestProperties*)(0))->mColor3 );
    pClass->AddProperty(&mColor3Property);

    // mColor4
    static PropertyColor4f mColor4Property("Color4", "", (UInt32)&((TestProperties*)(0))->mColor4 );
    pClass->AddProperty(&mColor4Property);

    // mVector3
    static PropertyVector3f mVector3Property("Vector3", "", (UInt32)&((TestProperties*)(0))->mVector3 );
    pClass->AddProperty(&mVector3Property);

    // mQuaternion
    static PropertyQuaternionf mQuaternionProperty("Quaternion", "", (UInt32)&((TestProperties*)(0))->mQuaternion );
    pClass->AddProperty(&mQuaternionProperty);

    // mString
    static PropertyString mStringProperty("String", "", (UInt32)&((TestProperties*)(0))->mString );
    pClass->AddProperty(&mStringProperty);

    // mEnum
    static TPropertyEnum<EnumInfo::TestProperties::MyEnum> mEnumProperty("Enum", "", (UInt32)&((TestProperties*)(0))->mEnum );
    pClass->AddProperty(&mEnumProperty);

}


} // namespace Gamedesk


#endif
